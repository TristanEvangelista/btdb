import java.util.*;
import java.io.*;


//java -Xmx32M btdb Data.bt Data.values
//BTree visualization, see which one it promotes for even number in splitting

public class btdb{
	
	public final static int MaxChildrenNodes = 3;	
	public final static int MaxKeys = MaxChildrenNodes-1;
	
	//BTree stuff
	public static RandomAccessFile btFile;
	public static long numberOfNodes = 0;
	public static int maxInList = (3*MaxChildrenNodes)-1;
	
	//Byte stuff
	public final static int MaxByteSizeValueRecord = 258;
	public final static int ByteSizeHeader = 8;
	public static long offsetInitialBytes = ByteSizeHeader*2;
	public static long nodeLengthBytes = maxInList * 8;
	
	public static void main(String args[])throws IOException{
    	Scanner in = new Scanner(System.in);
		String ignoredString = "";
		String bt = args[0];
		String values = args[1];
		File newbtFile = new File(bt);
		File newvaluesFile = new File(values);
		RandomAccessFile btFile = new RandomAccessFile(bt,"rwd");
		RandomAccessFile valuesFile = new RandomAccessFile(values,"rwd");
		
		//Beginning of values file
		long numberOfRecords = 0;
		long recordPlace = 0;
		long valueRecordNumber = 0;
		valuesFile.seek(0);
		valuesFile.writeLong(numberOfRecords);
		
		//Initialize BTree variables
			//byte stuff
		long maxByteSizeBTData = maxInList*ByteSizeHeader;
			//other stuff
		long locationOfRootNode = 0;
		
		//Updates the number of Nodes
		btFile.seek(0);
		btFile.writeLong(numberOfNodes);
		
		//Updates the location of the root Node
		btFile.seek(ByteSizeHeader);
		btFile.writeLong(locationOfRootNode);
		
		Node source = new Node(0); 
		writeToNode(source);
		
		while(in.hasNext()){
			String command = in.next();
			if(command.equals("insert") || command.equals("update") || command.equals("select") || command.equals("exit")){
				if(command.equals("insert")){
					long insertKey = Integer.parseInt(in.next());
					String valueString = in.nextLine();
					
					//check if key exists already
					if(insertKey == searchNodes(insertKey, locationOfRootNode)){
						System.out.println("ERROR: " + insertKey + " already exists.");
						continue;
					}
					
					//updates BTree
					insert(insertKey, locationOfRootNode, numberOfRecords);					
					//Writes Header into the BTree file
					btFile.seek(0);
					btFile.writeLong(numberOfNodes);
					btFile.seek(ByteSizeHeader);
					btFile.writeLong(locationOfRootNode);
					
					//Writes into the valuesFile
					byte[] valueByteArray = valueString.getBytes("UTF8");
					int stringLengthOfBytes = valueByteArray.length;
					valuesFile.seek(ByteSizeHeader + numberOfRecords*MaxByteSizeValueRecord);
					valuesFile.writeShort(stringLengthOfBytes);
					valuesFile.write(valueString.getBytes("UTF8"));
					
					//Updates the header of valuesFile
					numberOfRecords++;
					valuesFile.seek(0);
					valuesFile.writeLong(numberOfRecords);
					System.out.println(insertKey + " inserted.");
					locationOfRootNode = findRoot();
				}
				
				if(command.equals("update")){
					long updateKey = Integer.parseInt(in.next());
					String valueString = in.nextLine();
					
					//Check if key doesn't exist
					if(searchNodes(updateKey, locationOfRootNode) == -1){
						System.out.println("ERROR: " + updateKey + " does not exist.");
						continue;
					}
					
					//Use key to find place in BTree	
					valueRecordNumber = searchNodes(updateKey, locationOfRootNode);
					btFile.seek(valueRecordNumber);
					
					//Writes into the valuesFile
					byte[] valueByteArray = valueString.getBytes("UTF8");
					int stringLengthOfBytes = valueByteArray.length;
					recordPlace = (ByteSizeHeader*2 + valueRecordNumber*maxByteSizeBTData);
					valuesFile.seek(recordPlace);
					valuesFile.writeShort(stringLengthOfBytes);
					valuesFile.write(valueString.getBytes("UTF8"));
				}
				
				if(command.equals("select")){
					long selectKey = Integer.parseInt(in.next());
					
					//Check if key doesn't exist
					
					if(searchNodes(selectKey, locationOfRootNode) == -1){
						ignoredString = in.nextLine();
						System.out.println("ERROR: " + selectKey + " does not exist.");
						continue;
					}
					
					//find the proper place using the key and BTree
					valueRecordNumber = searchNodes(selectKey, locationOfRootNode);
					btFile.seek(valueRecordNumber);
					
					//finds inside valuesFile
					recordPlace = (ByteSizeHeader*2 + valueRecordNumber*maxByteSizeBTData);
					valuesFile.seek(recordPlace);
					int stringLengthOfBytes = valuesFile.readShort(); 
					byte[] valueByteArray = new byte[stringLengthOfBytes];
					int valueByteArrayRead = valuesFile.read(valueByteArray);
					String valueString = new String(valueByteArray, "UTF-8");
					System.out.println(selectKey + " => " + valueString);
				}
				if(command.equals("exit")){
					break;
				}
			}else{
				ignoredString = in.nextLine();
				System.out.println("ERROR: invalid command");
			}
		} //end of while loop for inputs
	}
	//method for inserting
	public static void insert(long key, long position, long offset) throws IOException{
		Node temp = readNode(position);
		if(temp.isLeaf()){
			temp.insertKey(key, offset);	
		}else{
			long newPosition = temp.getKey(key);
			temp = null;
			insert(key, newPosition, offset);
		}
		if(temp != null){
			if(temp.nodeKeys[MaxKeys] != -1){
				split(temp);    
				btFile.seek(0);
				btFile.writeLong(numberOfNodes);
			}else{
				writeToNode(temp);    
			}
			temp = null;
		}
    }
	//method for writing
	private static void writeToNode(Node node) throws IOException{ //Writes the Node's values onto a file
		btFile.seek(offsetInitialBytes + node.nodeID * nodeLengthBytes);
		btFile.writeLong(node.parentID);
		for(int i = 0; i < MaxChildrenNodes; i++){
			btFile.writeLong(node.childrenIDs[i]);
			if(i != MaxKeys){
				btFile.writeLong(node.nodeKeys[i]);
				btFile.writeLong(node.offsetOfValues[i]);
			}
		}
    }
	//method for searching
	public static long searchNodes(long key, long position) throws IOException{ //Recursively searches for a Key in one of the BTree's Nodes
		Node seeker = readNode(position);
		long newPosition;
		for(int i = 0; i < MaxKeys; i++){
			if(seeker.nodeKeys[i] == key){
				return seeker.offsetOfValues[i];    
			}
			else if(seeker.nodeKeys[i] < key && seeker.nodeKeys[i + 1] == 1 && seeker.childrenIDs[i + 1] != -1){
				newPosition = seeker.childrenIDs[i + 1]; seeker = null;
				return searchNodes(key, newPosition);
			}
			else if(seeker.nodeKeys[i] > key && seeker.childrenIDs[i] != -1){
				newPosition = seeker.childrenIDs[i]; seeker = null;
				return searchNodes(key, newPosition);
			}
			else if(i == MaxChildrenNodes - 2 && seeker.childrenIDs[i + 1] != -1){
				newPosition = seeker.childrenIDs[i + 1]; seeker = null;
				return searchNodes(key, newPosition);
			}
		}
		return -1;
    }
	//method for reading
	private static Node readNode(long position) throws IOException{
		btFile.seek(offsetInitialBytes + position * nodeLengthBytes);
		Node toRead = new Node(position);
		toRead.parentID = btFile.readLong();
		for(int i = 0; i < MaxChildrenNodes; i++){
			toRead.childrenIDs[i] = btFile.readLong();
			if(i != MaxKeys){
				toRead.nodeKeys[i] = btFile.readLong();
				toRead.offsetOfValues[i] = btFile.readLong();
			}
		}
		return toRead;
    }
	
	//methed for splitting
	private static void split(Node node) throws IOException{
		if(node.parentID == -1){
			Node y = new Node(numberOfNodes); numberOfNodes++; 
			Node root = new Node(numberOfNodes); numberOfNodes++;
			node.transfer(root, y);
			node.parentID = root.nodeID; y.parentID = root.nodeID;
			root.addChild(node.nodeID);
			root.addChild(y.nodeID);
			writeToNode(node); writeToNode(y); writeToNode(root);
			btFile.seek(8); btFile.writeLong(root.nodeID);
			node = null; y = null; root = null; 
		}else{
			Node ancestor = readNode(node.parentID); 
			Node y = new Node(numberOfNodes); numberOfNodes++;
			node.transfer(ancestor, y); ancestor.addChild(y.nodeID); y.parentID = ancestor.nodeID;
			attach(y);
			writeToNode(y); writeToNode(node);
			if(ancestor.nodeKeys[MaxKeys] != - 1){
				split(ancestor);    
			}
			writeToNode(ancestor);
		}
    }
    private static void attach(Node ancestor) throws IOException{
		for(int i = 0; i < MaxKeys / 2; i++){
			if(ancestor.childrenIDs[i] == - 1){
				break;    
			}
			btFile.seek(offsetInitialBytes + ancestor.childrenIDs[i] * nodeLengthBytes); 
			btFile.writeLong(ancestor.nodeID);
		}
    }    
	public static long findRoot()throws IOException{
		btFile.seek(ByteSizeHeader);
		return btFile.readLong();
	}	
}

class Node{
	private final int MaxChildrenNodes = 3;
	private final int MaxKeys = MaxChildrenNodes-1;
	long nodeID;
	long parentID;
	long[] nodeKeys;
	long[] childrenIDs;
	long[] offsetOfValues;
	
	public Node(long NodeNumber){
		long[] nodeKeys = new long[MaxKeys];
		long[] childrenIDs = new long[MaxChildrenNodes];
		long[] offsetOfValues = new long[MaxKeys];
		long nodeID = NodeNumber;
		long parentID = -1;
		Arrays.fill(nodeKeys, -1);
		Arrays.fill(childrenIDs, -1);
		Arrays.fill(offsetOfValues, -1);
	}
	
	public boolean isLeaf(){
		if(childrenIDs[0] != -1){
			return true;
		}
		return false;
	}
	
	public void addChild(long position){
		for(int i = 0; i < MaxChildrenNodes; i++){
			if(childrenIDs[i] == -1){
				childrenIDs[i] = position;
				break;
			}
		}
	}
	
	public long getKey(long key){
		long ID = -1;
		for(int i = 0; i < MaxKeys; i++){
			if(key > nodeKeys[i] && key < nodeKeys[i + 1] || nodeKeys[i + 1] == -1){
				return childrenIDs[i + 1];	
			}
			else if(key < nodeKeys[i]){
				return childrenIDs[i];
			}
	    }
		return ID;
	}
	
	public void insertKey(long key, long offset){
	    for(int i = MaxChildrenNodes - 2; i >= 0; i--){
			if(nodeKeys[i] == -1){
				if(i == 0){
					nodeKeys[i] = key;  
					offsetOfValues[i] = offset;
				}
			}
			if(key < nodeKeys[i]){
				nodeKeys[i + 1] = nodeKeys[i];
				offsetOfValues[i + 1] = offsetOfValues[i];
				childrenIDs[i + 2] = childrenIDs[i + 1];
				if(i == 0){
					nodeKeys[i] = key;
					offsetOfValues[i] = offset;
					childrenIDs[i + 1] = -1;
				}
			}
			else{
				nodeKeys[i + 1] = key;
				offsetOfValues[i + 1] = offset;
				childrenIDs[i + 2] = -1; 
			}
	    }
    }
	
	public void transfer(Node parent, Node offspring){
		parent.insertKey(nodeKeys[MaxKeys / 2], offsetOfValues[MaxKeys / 2]); 
		nodeKeys[MaxKeys / 2] = -1; 
		offsetOfValues[MaxKeys / 2] = -1; 
		for(int i = (MaxKeys / 2) + 1; i <= MaxChildrenNodes; i++){
			offspring.addChild(childrenIDs[i]);
			childrenIDs[i] = -1;
			if(i < MaxChildrenNodes){
				offspring.insertKey(nodeKeys[i], offsetOfValues[i]);
				nodeKeys[i] = -1;
				offsetOfValues[i] = -1;
			}
		}
    }
	
}
