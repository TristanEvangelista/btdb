import java.util.*;
import java.io.*;


//java -Xmx32M btdb2 Data.bt Data.values
public class btdb{
	
	public final static int MaxChildrenNodes = 5;	
	public final static int MaxByteSizeValueRecord = 256;
	public final static int ByteSizeHeader = 8;
	
	public static void main(String args[])throws IOException{
    	Scanner in = new Scanner(System.in);
		String bt = args[0];
		String values = args[1];
		File newbtFile = new File(bt);
		File newvaluesFile = new File(values);
		RandomAccessFile btFile = new RandomAccessFile(bt,"rwd");
		RandomAccessFile valuesFile = new RandomAccessFile(values,"rwd");
		
		//Beginning of values file
		long numberOfRecords = 0;
		long recordPlace = 0;
		valuesFile.seek(0);
		valuesFile.writeLong(numberOfRecords);
		
		//Initialize BTree variables
		long locationOfRootNode = 0;
		long numberOfNodes = 0;
		long offsetNumberOfRoot = 0; 
		long offsetInitial = ByteSizeHeader*2;
		int maxInList = (3*MaxChildrenNodes)-1;
		long nodeLength = maxInList * 8;
		long maxByteSizeBTData = maxInList*ByteSizeHeader;
		long[] listOfPointers = new long[maxInList];
		
		//Updates the number of Nodes
		btFile.seek(0);
		btFile.writeLong(numberOfNodes);
			
		//Updates the location of the root Node
		btFile.seek(ByteSizeHeader);
		btFile.writeLong(locationOfRootNode);
		
		Node source = new Node(0); 
		writeToNode(source);
		source = null;
		
		while(in.hasNext()){
			String command = in.next();
			if(command.equals("insert") || command.equals("update") || command.equals("select") || command.equals("exit")){
				if(command.equals("insert")){
					long insertKey = Integer.parseInt(in.next());
					String valueString = in.nextLine();
					//updates BTree
					
					
					
					//updates BTfile
					
					
					
					//Writes into the valuesFile
					byte[] valueByteArray = valueString.getBytes("UTF8");
					int stringLengthOfBytes = valueByteArray.length;
					valuesFile.seek(ByteSizeHeader + numberOfRecords*MaxByteSizeValueRecord);
					valuesFile.writeShort(stringLengthOfBytes);
					valuesFile.write(valueString.getBytes("UTF8"));
					
					//Updates the header of valuesFile
					numberOfRecords++;
					valuesFile.seek(0);
					valuesFile.writeLong(numberOfRecords);
					System.out.println(insertKey + " inserted.");
				}
				
				if(command.equals("update")){
					long updateKey = Integer.parseInt(in.next());
					String valueString = in.nextLine();
					
					//Writes into the valuesFile
					byte[] valueByteArray = valueString.getBytes("UTF8");
					int stringLengthOfBytes = valueByteArray.length;
					
					//Use key to find place in BTree
					
					//find the proper place using the key and BTree
					long ID = 0;
					btFile.seek(0);
					
					recordPlace = (ByteSizeHeader*2 + ID*maxByteSizeBTData);
					valuesFile.seek(recordPlace);
					valuesFile.writeShort(stringLengthOfBytes);
					valuesFile.write(valueString.getBytes("UTF8"));
				}
				
				if(command.equals("select")){
					long selectKey = Integer.parseInt(in.next());
					
					//find the proper place using the key and BTree
					long ID = 0;
					btFile.seek(0);
					
					recordPlace = (ByteSizeHeader*2 + ID*maxByteSizeBTData);
					
					
					//finds inside valuesFile
					valuesFile.seek(recordPlace);
					int stringLengthOfBytes = valuesFile.readShort(); 
					byte[] valueByteArray = new byte[stringLengthOfBytes];
					int valueByteArrayRead = valuesFile.read(valueByteArray);
					String valueString = new String(valueByteArray, "UTF-8");
					System.out.println(selectKey + " => " + valueString);
				}
				if(command.equals("exit")){
					break;
				}
			}else{
				System.out.println("ERROR: invalid command");
			}
		} //end of while loop for inputs
	}
	
	//method for inserting
	public void insert(long key, long position, long offset) throws IOException{
		Node temp = readNode(position);
		if(temp.leaf()){
			temp.keyInsert(key, offset);	
		}else{
			long newPosn = temp.getKey(key);
			temp = null;
			insert(key, newPosn, offset);
		}
		if(temp != null){
			if(temp.keyArr[MaxChildrenNodes - 1] != -1){
				split(temp);    
				btFile.seek(0);
				btFile.writeLong(numberOfNodes);
			}else{
				writeToNode(temp);    
			}
			temp = null;
		}
	}
	
	//method for writing
	private void writeToNode(Node node) throws IOException{ 
		btFile.seek(offsetInitial + node.nodeID * nodeLng);
		btFile.writeLong(node.parentPntr);
		for(int i = 0; i < MaxChildrenNodes; i++){
			btFile.writeLong(node.childArr[i]);
			if(i != MaxChildrenNodes - 1){
				btFile.writeLong(node.keyArr[i]);
				btFile.writeLong(node.recordOffset[i]);
			}
		}
	}
	
	//method for searching
	public long searchNodes(long dex, long position) throws IOException{
		Node seeker = readNode(position);
		long newPosn;
		for(int i = 0; i < MaxChildrenNodes - 1; i++){
			if(seeker.keyArr[i] == dex){
				return seeker.recordOffset[i];    
			}
			else if(seeker.keyArr[i] < dex && seeker.keyArr[i + 1] == 1 && seeker.childArr[i + 1] != -1){
				newPosn = seeker.childArr[i + 1]; seeker = null;
				return searchNodes(dex, newPosn);
			}
			else if(seeker.keyArr[i] > dex && seeker.childArr[i] != -1){
				newPosn = seeker.childArr[i]; seeker = null;
				return searchNodes(dex, newPosn);
			}
			else if(i == MaxChildrenNodes - 2 && seeker.childArr[i + 1] != -1){
				newPosn = seeker.childArr[i + 1]; seeker = null;
				return searchNodes(dex, newPosn);
			}
		}
		return -1;
	}
	
	//method for reading
	private Node readNode(long position) throws IOException{
		btFile.seek(offsetInitial + position * nodeLng);
		Node toRead = new Node(position);
		toRead.parentPntr = btFile.readLong();
		for(int i = 0; i < MaxChildrenNodes; i++){
			toRead.childArr[i] = btFile.readLong();
			if(i != MaxChildrenNodes - 1){
				toRead.keyArr[i] = btFile.readLong();
				toRead.recordOffset[i] = btFile.readLong();
			}
		}
		return toRead;
	}
	
	//methed for splitting
	private void split(Node node) throws IOException{
		if(node.parentPntr == -1){
			Node y = new Node(numberOfNodes); numberOfNodes++; 
			Node root = new Node(numberOfNodes); numberOfNodes++;
			node.transfer(root, y);
			node.parentPntr = root.nodeID; y.parentPntr = root.nodeID;
			root.addChild(node.nodeID);
			root.addChild(y.nodeID);
			writeToNode(node); writeToNode(y); writeToNode(root);
			btFile.seek(8); btFile.writeLong(root.nodeID);
			node = null; y = null; root = null; 
		}else{
			Node ancestor = readNode(node.parentPntr); 
			Node y = new Node(numberOfNodes); numberOfNodes++;
			node.transfer(ancestor, y); ancestor.addChild(y.nodeID); y.parentPntr = ancestor.nodeID;
			attach(y);
			writeToNode(y); writeToNode(node);
			if(ancestor.keyArr[MaxChildrenNodes - 1] != - 1){
				split(ancestor);    
			}
			writeToNode(ancestor);
		}
	}
	private void attach(Node ancestor) throws IOException{
		for(int i = 0; i < (MaxChildrenNodes - 1) / 2; i++){
			if(ancestor.childArr[i] == - 1){
				break;    
			}
			btFile.seek(offsetInitial + ancestor.childArr[i] * nodeLng); btFile.writeLong(ancestor.nodeID);
		}
	}    
}

class Node{
    long[] childArr; 
    long[] keyArr; 
    long[] recordOffset; 
    long parentPntr;
	long nodeID; 
    
    public Node(long position){
	keyArr = new long[MaxChildrenNodes]; 
    childArr = new long[MaxChildrenNodes + 1]; 
	recordOffset = new long[MaxChildrenNodes];
	parentPntr = -1;
	nodeID = position;
	for(int i = 0; i < MaxChildrenNodes; i++){
		childArr[i] = -1;
		if(i < MaxChildrenNodes){
		   keyArr[i] = -1;
		   recordOffset[i] = -1;
		}
	}
    }   
    
    public boolean leaf(){ 
		if(childArr[0] != -1){
			return true;	
		}
		return false;
    }
	
    public long getKey(long dex){ 
	    long id = -1; 
	    for(int i = 0; i < MaxChildrenNodes - 1; i++){
			if(dex > keyArr[i] && dex < keyArr[i + 1] || keyArr[i + 1] == -1){
				return childArr[i + 1];	
			}
			else if(dex < keyArr[i]){
				return childArr[i];
			}
	    }
       	return id;
    }
    
    public void addChild(long position){ 
        for(int i = 0; i < MaxChildrenNodes; i++){
			if(childArr[i] == 1){
				childArr[i] = position;
				break;
			}
		}
    }

    public void keyInsert(long key, long offset){ 
	    for(int i = MaxChildrenNodes - 2; i >= 0; i--){
			if(keyArr[i] == -1){
				if(i == 0){
					keyArr[i] = key;  
					recordOffset[i] = offset;
				}
			}
			
			if(key < keyArr[i]){
				keyArr[i + 1] = keyArr[i];
				recordOffset[i + 1] = recordOffset[i];
				childArr[i + 2] = childArr[i + 1];
				if(i == 0){
					keyArr[i] = key;
					recordOffset[i] = offset;
					childArr[i + 1] = -1;
				}
			}
			else{
				keyArr[i + 1] = key;
				recordOffset[i + 1] = offset;
				childArr[i + 2] = -1; 
			}
	    }
    }

    public void transfer(Node parent, Node offspring){
		parent.keyInsert(keyArr[(MaxChildrenNodes - 1) / 2], recordOffset[(MaxChildrenNodes - 1) / 2]); 
		keyArr[(MaxChildrenNodes - 1) / 2] = -1; 
		recordOffset[(MaxChildrenNodes - 1) / 2] = -1; 
		for(int i = ((MaxChildrenNodes - 1) / 2) + 1; i <= MaxChildrenNodes; i++){
			offspring.addChild(childArr[i]);
			childArr[i] = -1;
			if(i < MaxChildrenNodes){
				offspring.keyInsert(keyArr[i], recordOffset[i]);
				keyArr[i] = -1;
				recordOffset[i] = -1;
			}
		}
    }
}
